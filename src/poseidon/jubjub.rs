/*
This module implements the extended twisted edwards and extended affine coordinates
described in the paper "Twisted Edwards Curves Revisited":

 - https://iacr.org/archive/asiacrypt2008/53500329/53500329.pdf
   Huseyin Hisil, Kenneth Koon-Ho Wong, Gary Carter, and Ed Dawson

        Information Security Institute,
        Queensland University of Technology, QLD, 4000, Australia
        {h.hisil, kk.wong, g.carter, e.dawson}@qut.edu.au

By using the extended coordinate system we can avoid expensive modular exponentiation
calls, for example - a scalar multiplication call (or multiple...) may perform only
one 3d->2d projection at the point where affine coordinates are necessary, and every
intermediate uses a much faster form.

# XXX: none of these functions are constant time, they should not be used interactively!
*/
// ax^2 + y^2 = 1 + dx^2y^2

use crate::poseidon::field::SNARK_SCALAR_FIELD;
use num_bigint::BigInt;
use std::{
    ops::{Add, Div},
    str::FromStr,
};

use super::field::FQ;

lazy_static! {
    pub static ref JUBJUB_Q: BigInt = SNARK_SCALAR_FIELD.clone();
    pub static ref JUBJUB_E: BigInt = BigInt::from_str(
        "21888242871839275222246405745257275088614511777268538073601725287587578984328"
    )
    .unwrap();
    pub static ref JUBJUB_C: BigInt = BigInt::from_str("8").unwrap();

    //L is the order of the prime-order subgroup generated by the base point
    pub static ref JUBJUB_L: BigInt = JUBJUB_E.clone().div(JUBJUB_C.clone()); // L*B = 0, and (2^C)*L == #E
    pub static ref JUBJUB_A: BigInt = BigInt::from_str("168700").unwrap();
    pub static ref JUBJUB_D: BigInt = BigInt::from_str("168696").unwrap();
}

pub struct Point {
    x: FQ,
    y: FQ,
}

impl Point {
    pub fn new(x: FQ, y: FQ) -> Self {
        Point { x, y }
    }

    // These numbers has beeen taken from https://eips.ethereum.org/EIPS/eip-2494
    pub fn generate() -> Self {
        let x = BigInt::from_str(
            "16540640123574156134436876038791482806971768689494387082833631921987005038935",
        )
        .unwrap();
        let y = BigInt::from_str(
            "20819045374670962167435360035096875258406992893633759881276124905556507972311",
        )
        .unwrap();
        Point {
            x: FQ::new(x),
            y: FQ::new(y),
        }
    }
}

// Add Implementation for calculation in babyjub
// https://eips.ethereum.org/EIPS/eip-2494
// λ = d * x1 * x2 * y1 * y2,
// x3 = (x1y2 + y1 * x2)/(1 + λ)
// y3 = (y1 * y2 − a * x1 * x2)/(1 − λ).

impl Add for Point {
    type Output = Self;

    fn add(self, rhs: Self) -> Self::Output {
        let zero = BigInt::from_str("0").unwrap();
        if self.x.get_n() == &zero && self.x.get_m() == &zero {
            return rhs;
        }

        let x1 = &self.x;
        let x2 = &rhs.x;
        let y1 = &self.y;
        let y2 = &rhs.y;
        let d = FQ::new(JUBJUB_D.clone());
        let a = FQ::new(JUBJUB_A.clone());

        let lambda = d * x1 * x2 * y1 * y2;
        let x3 = (x1 * y2 + y1 * x2) / (FQ::one() + &lambda);
        let y3 = (y1 * y2 - a * x1 * x2) / (FQ::one() - &lambda);

        Point { x: x3, y: y3 }
    }
}

#[cfg(test)]

mod tests {
    use super::*;

    #[test]
    pub fn point_add_test_1() {
        let point = Point::new(
            FQ::new(
                BigInt::from_str(
                    "5925710879559963920674585068280151559572021649049974518737186312396312983287",
                )
                .unwrap(),
            ),
            FQ::new(
                BigInt::from_str(
                    "16975020951829843291561856284829257584634286376639034318405002894754175986822",
                )
                .unwrap(),
            ),
        );
        let other = Point::new(
            FQ::new(
                BigInt::from_str(
                    "5925710879559963920674585068280151559572021649049974518737186312396312983287",
                )
                .unwrap(),
            ),
            FQ::new(
                BigInt::from_str(
                    "16975020951829843291561856284829257584634286376639034318405002894754175986822",
                )
                .unwrap(),
            ),
        );

        let sum = point.add(other);
        assert_eq!(
            *sum.x.get_n(),
            BigInt::from_str(
                "3921821752680400551661691533275335336907961697969280331905459386565873550491",
            )
            .unwrap()
        );
        assert_eq!(
            *sum.x.get_m(),
            BigInt::from_str(
                "21888242871839275222246405745257275088548364400416034343698204186575808495617",
            )
            .unwrap()
        );
        assert_eq!(
            *sum.y.get_n(),
            BigInt::from_str(
                "8522068897570808837785568881356377871354274006792075192589502922612862896342",
            )
            .unwrap()
        );
        assert_eq!(
            *sum.y.get_m(),
            BigInt::from_str(
                "21888242871839275222246405745257275088548364400416034343698204186575808495617",
            )
            .unwrap()
        );
    }

    #[test]
    pub fn point_add_test_2() {
        let point = Point::new(
            FQ::new(
                BigInt::from_str(
                    "10975113445185536695224737904225227344281568447400334915125839333792816477396",
                )
                .unwrap(),
            ),
            FQ::new(
                BigInt::from_str(
                    "18445435810976842694581549336952093637971779711294581156054437925992025486446",
                )
                .unwrap(),
            ),
        );
        let other = Point::new(
            FQ::new(
                BigInt::from_str(
                    "5925710879559963920674585068280151559572021649049974518737186312396312983287",
                )
                .unwrap(),
            ),
            FQ::new(
                BigInt::from_str(
                    "16975020951829843291561856284829257584634286376639034318405002894754175986822",
                )
                .unwrap(),
            ),
        );

        let sum = point.add(other);
        assert_eq!(
            *sum.x.get_n(),
            BigInt::from_str(
                "4991609103248925747358645194965349262579784734809679007552644294476920671344",
            )
            .unwrap()
        );
        assert_eq!(
            *sum.x.get_m(),
            BigInt::from_str(
                "21888242871839275222246405745257275088548364400416034343698204186575808495617",
            )
            .unwrap()
        );
        assert_eq!(
            *sum.y.get_n(),
            BigInt::from_str(
                "423391641476660815714427268720766993055332927752794962916609674122318189741",
            )
            .unwrap()
        );
        assert_eq!(
            *sum.y.get_m(),
            BigInt::from_str(
                "21888242871839275222246405745257275088548364400416034343698204186575808495617",
            )
            .unwrap()
        );
    }
}
