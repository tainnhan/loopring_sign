/*
This module implements the extended twisted edwards and extended affine coordinates
described in the paper "Twisted Edwards Curves Revisited":

 - https://iacr.org/archive/asiacrypt2008/53500329/53500329.pdf
   Huseyin Hisil, Kenneth Koon-Ho Wong, Gary Carter, and Ed Dawson

        Information Security Institute,
        Queensland University of Technology, QLD, 4000, Australia
        {h.hisil, kk.wong, g.carter, e.dawson}@qut.edu.au

By using the extended coordinate system we can avoid expensive modular exponentiation
calls, for example - a scalar multiplication call (or multiple...) may perform only
one 3d->2d projection at the point where affine coordinates are necessary, and every
intermediate uses a much faster form.

# XXX: none of these functions are constant time, they should not be used interactively!
*/
// ax^2 + y^2 = 1 + dx^2y^2

use crate::poseidon::field::SNARK_SCALAR_FIELD;
use num_bigint::BigInt;
use std::{ops::Div, str::FromStr};

use super::field::FQ;

lazy_static! {
    pub static ref JUBJUB_Q: BigInt = SNARK_SCALAR_FIELD.clone();
    pub static ref JUBJUB_E: BigInt = BigInt::from_str(
        "21888242871839275222246405745257275088614511777268538073601725287587578984328"
    )
    .unwrap();
    pub static ref JUBJUB_C: BigInt = BigInt::from_str("8").unwrap();

    //L is the order of the prime-order subgroup generated by the base point
    pub static ref JUBJUB_L: BigInt = JUBJUB_E.clone().div(JUBJUB_C.clone()); // L*B = 0, and (2^C)*L == #E
    pub static ref JUBJUB_A: BigInt = BigInt::from_str("168700").unwrap();
    pub static ref JUBJUB_D: BigInt = BigInt::from_str("168696").unwrap();
}

pub struct Point {
    x: FQ,
    y: FQ,
}

impl Point {
    pub fn new(x: BigInt, y: BigInt) -> Point {
        Point {
            x: FQ::new(x, None),
            y: FQ::new(y, None),
        }
    }

    // These numbers has beeen taken from https://eips.ethereum.org/EIPS/eip-2494
    pub fn generate() -> Point {
        let x = BigInt::from_str(
            "16540640123574156134436876038791482806971768689494387082833631921987005038935",
        )
        .unwrap();
        let y = BigInt::from_str(
            "20819045374670962167435360035096875258406992893633759881276124905556507972311",
        )
        .unwrap();
        Point {
            x: FQ::new(x, None),
            y: FQ::new(y, None),
        }
    }

    // implementation from loopring_sdk python add
    // def add(self, other):
    // 	assert isinstance(other, Point)
    // 	if self.x == 0 and self.y == 0:
    // 		return other
    // 	(u1, v1) = (self.x, self.y)
    // 	(u2, v2) = (other.x, other.y)
    // 	u3 = (u1*v2 + v1*u2) / (FQ.one() + JUBJUB_D*u1*u2*v1*v2)
    // 	v3 = (v1*v2 - JUBJUB_A*u1*u2) / (FQ.one() - JUBJUB_D*u1*u2*v1*v2)
    // 	return Point(u3, v3)
}
